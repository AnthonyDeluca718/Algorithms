Data Structures: 4
-- Dynamic Circular Array from 'C-Array': push, insert_middle, slice, delete, sort, pop, length

-- Python Node Classes: Next, First, val
-- Linked-List Class: Search, insert, delete
-- Binary Tree class



Sorting: 4
-- Heapsort
-- Quicksort (in place)
-- Mergesort
-- Insertion Sort



Part 1: 4

3-25 - You are given a search string and a magazine. You seek to generate all the characters in search string by cutting them out from the magazine. Give an algorithm to efficiently determine whether the magazine contains all the letters in the search string.

3-24 - What is the best data structure for maintaining URLs that have been visited by a Web crawler? Give an algorithm to test whether a given URL has already been visited, optimizing both space and time.

3-29 - Give an algorithm for finding an ordered word pair (e.g., “New York”) occurring with the greatest frequency in a given webpage. Which data structures would you use? Optimize both time and space.

4-36 - Consider an n × n array A containing integer elements (positive, negative, and zero). Assume that the elements in each row of A are in strictly increasing order, and the elements of each column of A are in strictly decreasing order. (Hence there cannot be two zeroes in the same row or the same column.) Describe an efficient algorithm that counts the number of occurrences of the element 0 in A. Analyze its running time.



Part 2: 10

3-26 - Implement versions of several different dictionary data structures, such as linked lists, binary trees, balanced binary search trees, and hash tables. Conduct experiments to assess the relative performance of these data structures in a simple application that reads a large text file and reports exactly one instance of each word that appears within it. This application can be efficiently implemented by maintaining a dictionary of all distinct words that have appeared thus far in the text and inserting/reporting each word that is not found. Write a brief report with your conclusions.

3-20 - Write a function to find the middle node of a singly-linked list.

3-21 - Write a function to compare whether two binary trees are identical. Identical trees have the same key value at each position and the same structure.

3-22 - Write a program to convert a binary search tree into a linked list.

3-23 - Implement an algorithm to reverse a linked list. Now do it without recursion.

3-27 - Determine whether a linked list contains a loop as quickly as possible without using any extra storage. Also, identify the location of the loop.

4-37 - Implement versions of several different sorting algorithms, such as selection sort, insertion sort, heapsort, mergesort, and quicksort.

4-38 - Implement an external sort, which uses intermediate files to sort files bigger than main memory. Mergesort is a good algorithm to base such an implementation on. Test your program both on files with small records and on files with large records.

4-39 - Design and implement a parallel sorting algorithm that distributes data across several processors. An appropriate variation of mergesort is a likely candidate. Mea- sure the speedup of this algorithm as the number of processors increases. Later, compare the execution time to that of a purely sequential mergesort implementation. What are your experiences?

4-43 - You have a computer with only 2Mb of main memory. How do you use it to sort a large file of 500 Mb that is on disk?
